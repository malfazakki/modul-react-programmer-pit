# BAB 3.3: Performance Optimization

## Tujuan Pembelajaran:

*   Memahami masalah kinerja umum di React.
*   Mampu menerapkan teknik optimasi menggunakan `React.memo`, `useMemo`, dan `useCallback`.
*   Mampu menggunakan *React DevTools profiler* untuk mengidentifikasi *bottleneck* kinerja.
*   Memahami konsep dasar *Code Splitting*.
*   Mampu mengimplementasikan *Lazy Loading Components*.

## Materi Pembelajaran:

### 1. Performance Issue in React

Masalah kinerja di React seringkali muncul dari *re-rendering* komponen yang tidak perlu. Ingat, React akan me-*re-render* komponen setiap kali *state* atau *props*-nya berubah. Jika komponen induk di-*re-render*, secara *default* semua komponen anaknya juga akan di-*re-render*, terlepas dari apakah *props* mereka benar-benar berubah atau tidak.

**Penyebab Umum Masalah Kinerja:**
*   **Re-rendering yang Tidak Perlu**: Komponen di-*render* ulang meskipun *props* atau *state* yang relevan tidak berubah.
*   **Perhitungan Mahal**: Fungsi atau logika yang memakan banyak waktu dieksekusi ulang pada setiap *render*.
*   **Ukuran Bundle Besar**: Ukuran *bundle* JavaScript aplikasi yang besar dapat memperlambat waktu *initial load*.
*   **Manipulasi DOM yang Berlebihan**: Meskipun React mengelola DOM secara efisien, operasi DOM yang sangat sering atau kompleks masih bisa menjadi *bottleneck*.

### 2. React.memo untuk Component Memoization

`React.memo` adalah *Higher-Order Component* (HOC) yang digunakan untuk mengoptimalkan *functional components* dengan melakukan *memoization*. Ini berarti React akan "mengingat" hasil *render* komponen dan akan melewatkan *re-rendering* jika *props* yang diterimanya sama dengan *props* dari *render* sebelumnya.

**Kapan Menggunakan `React.memo`?**
*   Ketika komponen Anda sering di-*render*.
*   Ketika komponen Anda menerima *props* yang sama di sebagian besar *render*.
*   Ketika *rendering* komponen tersebut mahal (membutuhkan banyak perhitungan atau elemen DOM).

**Contoh `React.memo`:**

```jsx
import React, { useState } from 'react';

// Komponen Anak yang Tidak Dioptimalkan
function UnoptimizedChild({ count }) {
  console.log('UnoptimizedChild di-render');
  return <p>Count (Unoptimized): {count}</p>;
}

// Komponen Anak yang Dioptimalkan dengan React.memo
const OptimizedChild = React.memo(function OptimizedChild({ count }) {
  console.log('OptimizedChild di-render');
  return <p>Count (Optimized): {count}</p>;
});

function ParentComponent() {
  const [parentCount, setParentCount] = useState(0);
  const [otherState, setOtherState] = useState(0); // State lain yang tidak diteruskan ke anak

  return (
    <div>
      <h2>Optimasi dengan React.memo</h2>
      <p>Parent Count: {parentCount}</p>
      <p>Other State: {otherState}</p>
      <button onClick={() => setParentCount(parentCount + 1)}>
        Tambah Parent Count
      </button>
      <button onClick={() => setOtherState(otherState + 1)}>
        Tambah Other State (akan me-render ulang anak tanpa memo)
      </button>

      <hr />

      {/* UnoptimizedChild akan selalu di-render ulang saat ParentComponent di-render */}
      <UnoptimizedChild count={parentCount} />

      {/* OptimizedChild hanya akan di-render ulang jika prop 'count' berubah */}
      <OptimizedChild count={parentCount} />
    </div>
  );
}

export default ParentComponent;
```
**Catatan**: `React.memo` melakukan perbandingan dangkal (*shallow comparison*) pada *props*. Jika *props* adalah objek atau fungsi yang dibuat ulang pada setiap *render* induk, `React.memo` mungkin tidak efektif. Di sinilah `useMemo` dan `useCallback` berperan.

### 3. useMemo dan useCallback Hooks

`useMemo` dan `useCallback` adalah *Hooks* yang digunakan untuk *memoization* nilai dan fungsi, masing-masing. Mereka membantu mencegah *re-rendering* yang tidak perlu dan perhitungan ulang yang mahal.

#### a. useMemo Hook

`useMemo` digunakan untuk *memoize* nilai yang dihitung. Ini akan menghitung ulang nilai hanya jika salah satu dependensinya berubah.

**Kapan Menggunakan `useMemo`?**
*   Ketika Anda memiliki perhitungan yang mahal yang tidak perlu diulang pada setiap *render*.
*   Ketika Anda perlu menyediakan objek atau *array* sebagai *prop* ke komponen yang di-*memoize* (`React.memo`) untuk mencegah *re-rendering* yang tidak perlu.

**Contoh Perhitungan Mahal yang Mudah Dipahami:**

```jsx
import React, { useState, useMemo } from 'react';

function ProductList({ products, searchTerm }) {
  const [sortBy, setSortBy] = useState('name');
  
  // PERHITUNGAN MAHAL: Filter dan sort produk
  // Tanpa useMemo: akan dijalankan setiap kali komponen re-render
  const filteredAndSortedProducts = useMemo(() => {
    console.log('üîÑ Melakukan filter dan sort produk...');
    
    // Simulasi perhitungan yang memakan waktu
    const startTime = performance.now();
    
    // Filter produk berdasarkan search term
    let filtered = products.filter(product => 
      product.name.toLowerCase().includes(searchTerm.toLowerCase())
    );
    
    // Sort produk berdasarkan kriteria
    filtered.sort((a, b) => {
      if (sortBy === 'name') {
        return a.name.localeCompare(b.name);
      } else if (sortBy === 'price') {
        return a.price - b.price;
      } else if (sortBy === 'rating') {
        return b.rating - a.rating;
      }
      return 0;
    });
    
    // Simulasi delay untuk menunjukkan perhitungan mahal
    const endTime = performance.now();
    console.log(`‚è±Ô∏è Waktu perhitungan: ${endTime - startTime}ms`);
    
    return filtered;
  }, [products, searchTerm, sortBy]); // Hanya jalankan ulang jika salah satu berubah

  return (
    <div>
      <h3>Daftar Produk</h3>
      <select value={sortBy} onChange={(e) => setSortBy(e.target.value)}>
        <option value="name">Urutkan berdasarkan Nama</option>
        <option value="price">Urutkan berdasarkan Harga</option>
        <option value="rating">Urutkan berdasarkan Rating</option>
      </select>
      
      <div>
        {filteredAndSortedProducts.map(product => (
          <div key={product.id} style={{ border: '1px solid #ccc', margin: '5px', padding: '10px' }}>
            <h4>{product.name}</h4>
            <p>Harga: Rp {product.price.toLocaleString()}</p>
            <p>Rating: {product.rating}/5</p>
          </div>
        ))}
      </div>
    </div>
  );
}

// Contoh data produk
const sampleProducts = [
  { id: 1, name: 'Laptop Gaming', price: 15000000, rating: 4.5 },
  { id: 2, name: 'Smartphone', price: 5000000, rating: 4.2 },
  { id: 3, name: 'Headphone', price: 800000, rating: 4.8 },
  { id: 4, name: 'Mouse Wireless', price: 200000, rating: 4.0 },
  { id: 5, name: 'Keyboard Mechanical', price: 1200000, rating: 4.6 },
];

function App() {
  const [searchTerm, setSearchTerm] = useState('');
  const [otherState, setOtherState] = useState(0);

  return (
    <div style={{ padding: '20px' }}>
      <h2>Contoh useMemo - Optimasi Perhitungan Mahal</h2>
      
      <input
        type="text"
        placeholder="Cari produk..."
        value={searchTerm}
        onChange={(e) => setSearchTerm(e.target.value)}
        style={{ width: '300px', padding: '8px', marginBottom: '10px' }}
      />
      
      <button onClick={() => setOtherState(otherState + 1)}>
        Update State Lain (Count: {otherState})
      </button>
      
      <p style={{ color: 'gray', fontSize: '14px' }}>
        üí° Coba ubah state lain di atas dan lihat di console. 
        Perhitungan filter/sort hanya akan dijalankan ulang jika search term atau sort berubah!
      </p>
      
      <ProductList products={sampleProducts} searchTerm={searchTerm} />
    </div>
  );
}

export default App;
```

**Apa yang Terjadi Tanpa useMemo?**
```jsx
// TANPA useMemo - perhitungan dijalankan setiap render
function ProductListWithoutMemo({ products, searchTerm }) {
  const [sortBy, setSortBy] = useState('name');
  
  // ‚ùå BURUK: Perhitungan mahal dijalankan setiap kali komponen re-render
  const filteredAndSortedProducts = products.filter(product => 
    product.name.toLowerCase().includes(searchTerm.toLowerCase())
  ).sort((a, b) => {
    if (sortBy === 'name') return a.name.localeCompare(b.name);
    if (sortBy === 'price') return a.price - b.price;
    if (sortBy === 'rating') return b.rating - a.rating;
    return 0;
  });

  // ... rest of component
}
```

#### b. useCallback Hook

`useCallback` digunakan untuk *memoize* fungsi. Ini akan mengembalikan versi fungsi yang di-*memoize* hanya jika salah satu dependensinya berubah. Ini sangat berguna ketika Anda meneruskan fungsi sebagai *prop* ke komponen anak yang di-*memoize* (`React.memo`).

**Kapan Menggunakan `useCallback`?**
*   Ketika Anda meneruskan fungsi *callback* ke komponen anak yang di-*memoize* (`React.memo`) untuk mencegah *re-rendering* yang tidak perlu dari komponen anak tersebut.
*   Ketika fungsi tersebut digunakan sebagai dependensi di `useEffect` atau `useMemo` lainnya.

**Contoh useCallback yang Mudah Dipahami:**

```jsx
import React, { useState, useCallback } from 'react';

// Komponen Anak yang di-memoize
const ExpensiveChild = React.memo(({ onAddToCart, product }) => {
  console.log(`üîÑ ExpensiveChild untuk ${product.name} di-render`);
  
  return (
    <div style={{ border: '1px solid #ddd', padding: '10px', margin: '5px' }}>
      <h4>{product.name}</h4>
      <p>Harga: Rp {product.price.toLocaleString()}</p>
      <button onClick={() => onAddToCart(product)}>
        Tambah ke Keranjang
      </button>
    </div>
  );
});

function ShoppingCart() {
  const [cart, setCart] = useState([]);
  const [otherState, setOtherState] = useState(0);

  // ‚ùå TANPA useCallback: Fungsi dibuat ulang setiap render
  // const handleAddToCart = (product) => {
  //   setCart(prevCart => [...prevCart, product]);
  // };

  // ‚úÖ DENGAN useCallback: Fungsi di-memoize, hanya dibuat ulang jika dependensi berubah
  const handleAddToCart = useCallback((product) => {
    console.log(`üõí Menambahkan ${product.name} ke keranjang`);
    setCart(prevCart => [...prevCart, product]);
  }, []); // Array kosong = fungsi tidak akan pernah dibuat ulang

  const clearCart = useCallback(() => {
    setCart([]);
  }, []);

  return (
    <div style={{ padding: '20px' }}>
      <h2>Contoh useCallback - Optimasi Callback Functions</h2>
      
      <button onClick={() => setOtherState(otherState + 1)}>
        Update State Lain (Count: {otherState})
      </button>
      
      <button onClick={clearCart} style={{ marginLeft: '10px' }}>
        Kosongkan Keranjang
      </button>
      
      <p style={{ color: 'gray', fontSize: '14px' }}>
        üí° Coba klik tombol "Update State Lain" dan lihat di console. 
        ExpensiveChild tidak akan di-render ulang karena callback-nya di-memoize!
      </p>

      <div style={{ display: 'flex', gap: '20px' }}>
        <div style={{ flex: 1 }}>
          <h3>Produk Tersedia</h3>
          {sampleProducts.map(product => (
            <ExpensiveChild 
              key={product.id} 
              product={product} 
              onAddToCart={handleAddToCart}
            />
          ))}
        </div>
        
        <div style={{ flex: 1 }}>
          <h3>Keranjang Belanja ({cart.length} item)</h3>
          {cart.map((item, index) => (
            <div key={index} style={{ padding: '5px', backgroundColor: '#f0f0f0' }}>
              {item.name} - Rp {item.price.toLocaleString()}
            </div>
          ))}
        </div>
      </div>
    </div>
  );
}

// Data produk yang sama
const sampleProducts = [
  { id: 1, name: 'Laptop Gaming', price: 15000000, rating: 4.5 },
  { id: 2, name: 'Smartphone', price: 5000000, rating: 4.2 },
  { id: 3, name: 'Headphone', price: 800000, rating: 4.8 },
];

export default ShoppingCart;
```

**Apa yang Terjadi Tanpa useCallback?**
```jsx
// TANPA useCallback - fungsi dibuat ulang setiap render
function ShoppingCartWithoutCallback() {
  const [cart, setCart] = useState([]);
  
  // ‚ùå BURUK: Fungsi dibuat ulang setiap kali komponen re-render
  // Ini menyebabkan ExpensiveChild (yang di-memoize) selalu re-render
  const handleAddToCart = (product) => {
    setCart(prevCart => [...prevCart, product]);
  };

  return (
    <div>
      {sampleProducts.map(product => (
        <ExpensiveChild 
          key={product.id} 
          product={product} 
          onAddToCart={handleAddToCart} // ‚ùå Referensi fungsi selalu baru
        />
      ))}
    </div>
  );
}
```

### 4. Perbedaan useMemo, useCallback, dan useEffect

**Tabel Perbandingan:**

| Hook | Tujuan | Kapan Dijalankan | Return Value | Contoh Penggunaan |
|------|--------|------------------|--------------|-------------------|
| **useMemo** | Memoize nilai/perhitungan | Saat dependensi berubah | Nilai yang dihitung | Perhitungan mahal, filter data |
| **useCallback** | Memoize fungsi | Saat dependensi berubah | Fungsi yang di-memoize | Callback untuk komponen anak |
| **useEffect** | Side effects | Setelah render selesai | Tidak ada (void) | API calls, subscriptions, DOM manipulation |

**Contoh Perbandingan Lengkap:**

```jsx
import React, { useState, useMemo, useCallback, useEffect } from 'react';

function ComparisonExample() {
  const [count, setCount] = useState(0);
  const [text, setText] = useState('');
  const [data, setData] = useState([]);

  // 1. useMemo - untuk memoize nilai/perhitungan
  const expensiveCalculation = useMemo(() => {
    console.log('üßÆ useMemo: Menghitung nilai mahal...');
    let result = 0;
    for (let i = 0; i < 1000000; i++) {
      result += count;
    }
    return result;
  }, [count]); // Hanya jalankan ulang jika count berubah

  // 2. useCallback - untuk memoize fungsi
  const handleClick = useCallback(() => {
    console.log('üñ±Ô∏è useCallback: Tombol diklik');
    setCount(prev => prev + 1);
  }, []); // Fungsi tidak akan pernah dibuat ulang

  // 3. useEffect - untuk side effects
  useEffect(() => {
    console.log('üåê useEffect: Melakukan API call...');
    // Simulasi API call
    setTimeout(() => {
      setData([{ id: 1, name: 'Data dari API' }]);
    }, 1000);
  }, []); // Hanya jalankan sekali saat komponen mount

  // useEffect lain untuk side effect yang bergantung pada count
  useEffect(() => {
    console.log('üìä useEffect: Count berubah menjadi', count);
    // Side effect yang bergantung pada count
  }, [count]);

  return (
    <div style={{ padding: '20px' }}>
      <h2>Perbedaan useMemo, useCallback, dan useEffect</h2>
      
      <div style={{ marginBottom: '20px' }}>
        <input
          type="text"
          value={text}
          onChange={(e) => setText(e.target.value)}
          placeholder="Ketik sesuatu untuk trigger re-render..."
          style={{ width: '300px', padding: '8px' }}
        />
      </div>

      <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '20px' }}>
        <div style={{ border: '1px solid #ccc', padding: '15px' }}>
          <h3>useMemo - Memoize Nilai</h3>
          <p>Count: {count}</p>
          <p>Hasil perhitungan mahal: {expensiveCalculation}</p>
          <p style={{ fontSize: '12px', color: 'gray' }}>
            üí° Perhitungan hanya dijalankan ulang jika count berubah
          </p>
        </div>

        <div style={{ border: '1px solid #ccc', padding: '15px' }}>
          <h3>useCallback - Memoize Fungsi</h3>
          <button onClick={handleClick}>
            Tambah Count (Callback di-memoize)
          </button>
          <p style={{ fontSize: '12px', color: 'gray' }}>
            üí° Fungsi tidak dibuat ulang, mencegah re-render anak
          </p>
        </div>
      </div>

      <div style={{ marginTop: '20px', border: '1px solid #ccc', padding: '15px' }}>
        <h3>useEffect - Side Effects</h3>
        <p>Data dari API: {data.length > 0 ? data[0].name : 'Loading...'}</p>
        <p style={{ fontSize: '12px', color: 'gray' }}>
          üí° useEffect untuk API calls, subscriptions, DOM manipulation
        </p>
      </div>

      <div style={{ marginTop: '20px', backgroundColor: '#f0f0f0', padding: '15px' }}>
        <h3>üìã Ringkasan Perbedaan:</h3>
        <ul>
          <li><strong>useMemo:</strong> "Saya ingin mengingat hasil perhitungan ini"</li>
          <li><strong>useCallback:</strong> "Saya ingin mengingat fungsi ini"</li>
          <li><strong>useEffect:</strong> "Saya ingin melakukan sesuatu setelah render"</li>
        </ul>
      </div>
    </div>
  );
}

export default ComparisonExample;
```

### 5. React DevTools Profiler

*React DevTools* adalah ekstensi *browser* yang sangat berguna untuk *debugging* dan *profiling* aplikasi React Anda. *Profiler* memungkinkan Anda untuk merekam sesi interaksi dengan aplikasi Anda dan melihat berapa lama waktu yang dibutuhkan setiap komponen untuk di-*render*.

**Cara Menggunakan Profiler:**
1.  Instal ekstensi *React DevTools* untuk *browser* Anda (Chrome/Firefox).
2.  Buka *Developer Tools* di *browser* Anda (F12).
3.  Pilih tab "Profiler".
4.  Klik tombol "Record" (lingkaran merah) untuk memulai perekaman.
5.  Lakukan interaksi di aplikasi Anda.
6.  Klik tombol "Stop" untuk menghentikan perekaman.
7.  Anda akan melihat grafik yang menunjukkan waktu *rendering* komponen. Komponen yang di-*highlight* dengan warna kuning/merah adalah yang memakan waktu *rendering* paling banyak.

*Profiler* membantu Anda mengidentifikasi *bottleneck* kinerja dan komponen mana yang paling sering di-*render* ulang secara tidak perlu.

### 6. Code Splitting Dasar

*Code splitting* adalah teknik untuk memecah *bundle* kode JavaScript Anda menjadi bagian-bagian yang lebih kecil yang dapat dimuat secara *on-demand*. Ini membantu mengurangi ukuran *bundle* awal yang harus diunduh pengguna, sehingga mempercepat waktu *initial load* aplikasi Anda.

**Cara Kerja:**
*Code splitting* biasanya dilakukan pada level rute atau komponen. Ketika pengguna menavigasi ke rute tertentu atau ketika komponen tertentu dibutuhkan, *chunk* kode yang relevan akan dimuat.

### 7. Lazy Loading Components

*Lazy loading* adalah implementasi dari *code splitting* di mana komponen hanya dimuat saat dibutuhkan. React menyediakan `React.lazy()` dan `Suspense` untuk memfasilitasi *lazy loading*.

*   **`React.lazy()`**: Fungsi ini memungkinkan Anda untuk me-*render* impor dinamis sebagai komponen React biasa.
*   **`React.Suspense`**: Komponen ini memungkinkan Anda untuk menampilkan *fallback content* (misalnya, indikator *loading*) saat komponen yang di-*lazy-load* sedang dimuat.

**Contoh Lazy Loading Components:**

```jsx
import React, { useState, Suspense } from 'react';

// Menggunakan React.lazy untuk lazy load komponen
const LazyLoadedComponent = React.lazy(() => import('./LazyLoadedComponent'));

// LazyLoadedComponent.js (file terpisah)
// import React from 'react';
// function LazyLoadedComponent() {
//   return <div>Ini adalah komponen yang dimuat secara lazy!</div>;
// }
// export default LazyLoadedComponent;


function App() {
  const [showLazy, setShowLazy] = useState(false);

  return (
    <div>
      <h2>Lazy Loading Components</h2>
      <button onClick={() => setShowLazy(true)}>
        Tampilkan Komponen Lazy
      </button>

      {showLazy && (
        <Suspense fallback={<div>Memuat komponen...</div>}>
          {/* Komponen ini hanya akan dimuat saat showLazy true */}
          <LazyLoadedComponent />
        </Suspense>
      )}
    </div>
  );
}

export default App;
```

Dengan menerapkan teknik-teknik optimasi ini, Anda dapat secara signifikan meningkatkan kinerja aplikasi React Anda, memberikan pengalaman pengguna yang lebih cepat dan responsif.

---

## Rangkuman

### Apa yang Telah Dipelajari

Pada modul **BAB 3.3: Performance Optimization**, kita telah mempelajari teknik-teknik utama untuk meningkatkan kinerja aplikasi React:

#### 1. **Performance Issue in React**
- Penyebab umum masalah kinerja: re-rendering tidak perlu, perhitungan mahal, bundle besar, manipulasi DOM berlebihan

#### 2. **React.memo untuk Component Memoization**
- Mencegah re-rendering komponen anak jika props tidak berubah
- Cocok untuk komponen yang sering di-render dan menerima props yang sama

#### 3. **useMemo dan useCallback Hooks**
- useMemo: memoize nilai/perhitungan mahal agar tidak dihitung ulang jika dependensi tidak berubah
- useCallback: memoize fungsi agar referensi fungsi tetap stabil, mencegah re-rendering anak yang di-memoize

#### 4. **React DevTools Profiler**
- Alat untuk mengidentifikasi bottleneck kinerja dan komponen yang sering di-render ulang
- Membantu menemukan area yang perlu dioptimasi

#### 5. **Code Splitting Dasar**
- Memecah bundle menjadi bagian kecil yang dimuat on-demand
- Mengurangi waktu initial load aplikasi

#### 6. **Lazy Loading Components**
- Menggunakan React.lazy dan Suspense untuk memuat komponen hanya saat dibutuhkan
- Meningkatkan performa dan pengalaman pengguna

### Poin-Poin Penting

‚úÖ **React.memo** - cegah re-rendering anak yang tidak perlu  
‚úÖ **useMemo & useCallback** - optimasi perhitungan mahal dan fungsi callback  
‚úÖ **Profiler** - identifikasi bottleneck performa aplikasi  
‚úÖ **Code splitting & lazy loading** - percepat initial load dan efisiensi aplikasi  

---

## Evaluasi Harian

Berikut adalah tugas yang harus dikerjakan oleh santri pada hari kelima belas:

1. **Implementasi React.memo**
   - Buatlah komponen induk dengan state yang sering berubah dan komponen anak yang menerima props.
   - Implementasikan React.memo pada komponen anak untuk mencegah re-rendering yang tidak perlu.
   - Demonstrasikan perbedaan performa dengan console.log untuk melihat kapan komponen di-render.

2. **Optimasi dengan useMemo**
   - Buatlah komponen dengan perhitungan yang mahal (misal: loop besar atau operasi matematika kompleks).
   - Implementasikan useMemo untuk mengoptimalkan perhitungan tersebut.
   - Tunjukkan bahwa perhitungan hanya dijalankan ulang ketika dependensi berubah.

3. **Optimasi dengan useCallback**
   - Buatlah komponen induk yang meneruskan fungsi callback ke komponen anak yang di-memoize.
   - Implementasikan useCallback untuk mencegah re-rendering komponen anak yang tidak perlu.
   - Demonstrasikan perbedaan dengan dan tanpa useCallback.

4. **Code Splitting dan Lazy Loading**
   - Buatlah aplikasi dengan minimal 3 halaman/komponen yang berbeda.
   - Implementasikan React.lazy() dan Suspense untuk lazy loading komponen.
   - Tambahkan tombol navigasi untuk memuat komponen secara on-demand.

5. **Performance Profiling**
   - Buatlah aplikasi sederhana dengan beberapa komponen yang memiliki performa berbeda.
   - Gunakan React DevTools Profiler untuk mengidentifikasi bottleneck performa.
   - Dokumentasikan hasil profiling dan jelaskan optimasi yang dapat diterapkan.

> **Catatan:**
> - Tugas dikerjakan secara individu dan dikumpulkan dalam bentuk file markdown atau dokumen digital.
> - Sertakan hasil kode (screenshot atau link repository) pada setiap tugas yang membutuhkan implementasi React.
> - Untuk tugas profiling, sertakan screenshot dari React DevTools Profiler.
> - Pastikan setiap optimasi yang diterapkan memiliki penjelasan mengapa optimasi tersebut diperlukan.
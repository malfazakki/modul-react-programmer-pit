# BAB 4.2: Pengenalan TypeScript pada React

## Tujuan Pembelajaran

*   Memahami konsep dasar TypeScript dan manfaatnya dalam pengembangan React.
*   Mampu melakukan setup TypeScript pada proyek React.
*   Mampu menggunakan tipe data, interface, dan type alias dalam React.
*   Mampu mengimplementasikan TypeScript pada props, state, dan event handlers.
*   Memahami advanced TypeScript patterns dalam React.

## Materi Pembelajaran

### 1. Pengenalan TypeScript dan Setup

TypeScript adalah superset dari JavaScript yang menambahkan tipe statis ke bahasa pemrograman. TypeScript dikembangkan oleh Microsoft dan sangat populer dalam pengembangan React modern karena dapat meningkatkan produktivitas developer dan mengurangi bug.

*   **Manfaat TypeScript dalam React**:
    *   **Type Safety**: Mendeteksi error pada saat compile time, bukan runtime.
    *   **Better IDE Support**: Autocomplete, refactoring, dan navigation yang lebih baik.
    *   **Self-Documenting Code**: Tipe data berfungsi sebagai dokumentasi.
    *   **Easier Refactoring**: Lebih aman melakukan perubahan besar pada codebase.
    *   **Better Collaboration**: Memudahkan tim untuk memahami struktur data.

*   **Setup TypeScript pada React**:
    Untuk proyek baru dengan Create React App:
    ```bash
    npx create-react-app my-app --template typescript
    # atau
    npx create-react-app my-app --template cra-template-typescript
    ```

    Untuk proyek baru dengan Vite:
    ```bash
    npm create vite@latest my-app --template react-ts
    # atau
    yarn create vite my-app --template react-ts
    ```

    Untuk menambahkan TypeScript pada proyek React yang sudah ada:
    ```bash
    npm install --save-dev typescript @types/node @types/react @types/react-dom
    # atau
    yarn add --dev typescript @types/node @types/react @types/react-dom
    ```

    Setup file konfigurasi `tsconfig.json`:
    ```json
    {
      "compilerOptions": {
        "target": "es5",
        "lib": ["dom", "dom.iterable", "es6"],
        "allowJs": true,
        "skipLibCheck": true,
        "esModuleInterop": true,
        "allowSyntheticDefaultImports": true,
        "strict": true,
        "forceConsistentCasingInFileNames": true,
        "noFallthroughCasesInSwitch": true,
        "module": "esnext",
        "moduleResolution": "node",
        "resolveJsonModule": true,
        "isolatedModules": true,
        "noEmit": true,
        "jsx": "react-jsx"
      },
      "include": ["src"]
    }
    ```

### 2. Tipe Data Dasar dan Interface

TypeScript menyediakan berbagai tipe data yang dapat digunakan untuk membuat aplikasi React yang lebih aman dan terstruktur.

**Tipe Data Primitif:**
```typescript
// Boolean
const isLoading: boolean = true;

// Number
const count: number = 42;
const price: number = 99.99;

// String
const name: string = "John Doe";
const message: string = `Hello, ${name}!`;

// Array
const numbers: number[] = [1, 2, 3, 4, 5];
const names: Array<string> = ["Alice", "Bob", "Charlie"];

// Tuple (array dengan tipe fixed length dan ordered)
const person: [string, number] = ["John", 30];

// Enum
enum Status {
  Pending = "PENDING",
  InProgress = "IN_PROGRESS",
  Completed = "COMPLETED"
}

const currentStatus: Status = Status.InProgress;

// Any (hindari penggunaan kecuali sangat diperlukan)
let data: any = "could be anything";
```

**Interface untuk Props dan State:**
```typescript
// Interface untuk props komponen
interface UserCardProps {
  name: string;
  age: number;
  email?: string; // Optional property
  status: Status;
  hobbies: string[];
}

// Interface untuk state
interface UserState {
  user: {
    id: number;
    name: string;
    email: string;
  } | null;
  isLoading: boolean;
  error: string | null;
}
```

### 3. TypeScript dengan React Functional Components

TypeScript bekerja sangat baik dengan functional components dan React Hooks untuk memberikan type safety yang komprehensif.

**Function Component dengan TypeScript:**
```typescript
import React, { useState, useCallback, useMemo } from 'react';

// Komponen dengan typed props dan events
interface CounterProps {
  initialCount?: number;
  step?: number;
  onCountChange?: (count: number) => void;
  disabled?: boolean;
}

interface User {
  id: number;
  name: string;
  email: string;
  role: 'admin' | 'user' | 'guest';
}

interface CounterState {
  count: number;
  isEven: boolean;
  lastUpdated: Date | null;
}

const Counter: React.FC<CounterProps> = ({
  initialCount = 0,
  step = 1,
  onCountChange,
  disabled = false
}) => {
  const [state, setState] = useState<CounterState>({
    count: initialCount,
    isEven: initialCount % 2 === 0,
    lastUpdated: null
  });

  const increment = useCallback((): void => {
    if (disabled) return;

    setState(prevState => {
      const newCount = prevState.count + step;
      const newState: CounterState = {
        count: newCount,
        isEven: newCount % 2 === 0,
        lastUpdated: new Date()
      };

      onCountChange?.(newCount);
      return newState;
    });
  }, [step, onCountChange, disabled]);

  const decrement = useCallback((): void => {
    if (disabled) return;

    setState(prevState => {
      const newCount = prevState.count - step;
      const newState: CounterState = {
        count: newCount,
        isEven: newCount % 2 === 0,
        lastUpdated: new Date()
      };

      onCountChange?.(newCount);
      return newState;
    });
  }, [step, onCountChange, disabled]);

  const reset = useCallback((): void => {
    setState({
      count: initialCount,
      isEven: initialCount % 2 === 0,
      lastUpdated: new Date()
    });
    onCountChange?.(initialCount);
  }, [initialCount, onCountChange]);

  // Computed values dengan useMemo
  const displayInfo = useMemo((): string => {
    const status = state.isEven ? 'Genap' : 'Ganjil';
    const timeInfo = state.lastUpdated
      ? ` (terakhir diupdate: ${state.lastUpdated.toLocaleTimeString()})`
      : '';
    return `${status}${timeInfo}`;
  }, [state.isEven, state.lastUpdated]);

  return (
    <div>
      <h2>Counter: {state.count}</h2>
      <p>{displayInfo}</p>
      <div>
        <button onClick={increment} disabled={disabled}>
          +{step}
        </button>
        <button onClick={decrement} disabled={disabled}>
          -{step}
        </button>
        <button onClick={reset}>Reset</button>
      </div>
    </div>
  );
};

export default Counter;
```

**User Management Component dengan Complex Types:**
```typescript
import React, { useState, useReducer } from 'react';

// Complex interfaces untuk real-world scenario
interface UserProfile {
  id: number;
  personalInfo: {
    firstName: string;
    lastName: string;
    email: string;
    avatar?: string;
  };
  preferences: {
    theme: 'light' | 'dark' | 'auto';
    notifications: boolean;
    language: string;
  };
  stats: {
    loginCount: number;
    lastLogin: Date;
    accountCreated: Date;
  };
}

type UserAction =
  | { type: 'UPDATE_PROFILE'; payload: Partial<UserProfile['personalInfo']> }
  | { type: 'UPDATE_PREFERENCES'; payload: Partial<UserProfile['preferences']> }
  | { type: 'INCREMENT_LOGIN_COUNT' }
  | { type: 'RESET' };

const initialUser: UserProfile = {
  id: 1,
  personalInfo: {
    firstName: 'John',
    lastName: 'Doe',
    email: 'john.doe@example.com'
  },
  preferences: {
    theme: 'light',
    notifications: true,
    language: 'id'
  },
  stats: {
    loginCount: 0,
    lastLogin: new Date(),
    accountCreated: new Date()
  }
};

function userReducer(state: UserProfile, action: UserAction): UserProfile {
  switch (action.type) {
    case 'UPDATE_PROFILE':
      return {
        ...state,
        personalInfo: { ...state.personalInfo, ...action.payload }
      };
    case 'UPDATE_PREFERENCES':
      return {
        ...state,
        preferences: { ...state.preferences, ...action.payload }
      };
    case 'INCREMENT_LOGIN_COUNT':
      return {
        ...state,
        stats: {
          ...state.stats,
          loginCount: state.stats.loginCount + 1,
          lastLogin: new Date()
        }
      };
    case 'RESET':
      return initialUser;
    default:
      return state;
  }
}

const UserProfile: React.FC = () => {
  const [user, dispatch] = useReducer(userReducer, initialUser);
  const [isEditing, setIsEditing] = useState<boolean>(false);

  const handleProfileUpdate = (field: keyof UserProfile['personalInfo'], value: string): void => {
    dispatch({
      type: 'UPDATE_PROFILE',
      payload: { [field]: value }
    });
  };

  return (
    <div>
      <h2>User Profile</h2>
      <div>
        <h3>Personal Information</h3>
        <p>Name: {user.personalInfo.firstName} {user.personalInfo.lastName}</p>
        <p>Email: {user.personalInfo.email}</p>
        {isEditing ? (
          <div>
            <input
              type="text"
              value={user.personalInfo.firstName}
              onChange={(e) => handleProfileUpdate('firstName', e.target.value)}
              placeholder="First Name"
            />
            <input
              type="email"
              value={user.personalInfo.email}
              onChange={(e) => handleProfileUpdate('email', e.target.value)}
              placeholder="Email"
            />
            <button onClick={() => setIsEditing(false)}>Save</button>
          </div>
        ) : (
          <button onClick={() => setIsEditing(true)}>Edit Profile</button>
        )}
      </div>

      <div>
        <h3>Preferences</h3>
        <p>Theme: {user.preferences.theme}</p>
        <p>Notifications: {user.preferences.notifications ? 'Enabled' : 'Disabled'}</p>
        <p>Language: {user.preferences.language}</p>
      </div>

      <div>
        <h3>Statistics</h3>
        <p>Login Count: {user.stats.loginCount}</p>
        <p>Last Login: {user.stats.lastLogin.toLocaleDateString()}</p>
        <p>Member Since: {user.stats.accountCreated.toLocaleDateString()}</p>
        <button onClick={() => dispatch({ type: 'INCREMENT_LOGIN_COUNT' })}>
          Simulate Login
        </button>
      </div>
    </div>
  );
};

export default UserProfile;
```

### 4. Advanced TypeScript Patterns

TypeScript menyediakan berbagai advanced patterns yang sangat berguna dalam pengembangan React aplikasi yang kompleks.

**Generic Types:**
```typescript
// Generic function untuk API calls
async function fetchData<T>(url: string): Promise<T> {
  const response = await fetch(url);
  if (!response.ok) {
    throw new Error('Network response was not ok');
  }
  return response.json();
}

// Penggunaan dengan interface
interface User {
  id: number;
  name: string;
  email: string;
}

interface Post {
  id: number;
  title: string;
  content: string;
}

// Usage
const users = await fetchData<User[]>('/api/users');
const posts = await fetchData<Post[]>('/api/posts');
```

**Utility Types:**
```typescript
// Partial - membuat semua properties menjadi optional
interface User {
  id: number;
  name: string;
  email: string;
}

const updateUser = (user: Partial<User>): void => {
  // user sekarang memiliki properties yang optional
};

// Pick - memilih properties tertentu
type UserNameAndEmail = Pick<User, 'name' | 'email'>;

// Omit - menghilangkan properties tertentu
type UserWithoutId = Omit<User, 'id'>;

// Record - membuat object dengan key dan value type tertentu
type UserRoles = Record<string, 'admin' | 'user' | 'guest'>;
```

**Custom Hooks dengan TypeScript:**
```typescript
import { useState, useEffect, useCallback } from 'react';

// Custom hook dengan generic types
function useAsyncData<T>(
  asyncFunction: () => Promise<T>,
  dependencies: React.DependencyList = []
) {
  const [data, setData] = useState<T | null>(null);
  const [loading, setLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);

  const fetchData = useCallback(async () => {
    setLoading(true);
    setError(null);
    try {
      const result = await asyncFunction();
      setData(result);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'An error occurred');
    } finally {
      setLoading(false);
    }
  }, [asyncFunction]);

  useEffect(() => {
    fetchData();
  }, dependencies);

  return { data, loading, error, refetch: fetchData };
}

// Penggunaan custom hook
interface ApiResponse {
  users: Array<{
    id: number;
    name: string;
    email: string;
  }>;
}

const UserList: React.FC = () => {
  const { data, loading, error } = useAsyncData<ApiResponse>(
    () => fetch('/api/users').then(res => res.json()),
    []
  );

  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error}</div>;
  if (!data) return <div>No data</div>;

  return (
    <ul>
      {data.users.map(user => (
        <li key={user.id}>{user.name} - {user.email}</li>
      ))}
    </ul>
  );
};
```

### 5. Best Practices dan Error Handling

Menggunakan TypeScript dengan baik memerlukan pemahaman tentang best practices dan teknik error handling yang tepat.

**Type Assertions dan Type Guards:**
```typescript
// Type assertion
const someValue: unknown = "this is a string";
const strLength: number = (someValue as string).length;

// Type guard function
function isUser(obj: any): obj is User {
  return obj && typeof obj === 'object' && 'id' in obj && 'name' in obj;
}

// Penggunaan type guard
const handleData = (data: unknown): void => {
  if (isUser(data)) {
    // TypeScript sekarang tahu bahwa data adalah User
    console.log(data.name);
  }
};
```

**Error Boundaries dengan TypeScript:**
```typescript
import React, { Component, ReactNode } from 'react';

interface ErrorBoundaryProps {
  children: ReactNode;
  fallback?: ReactNode;
}

interface ErrorBoundaryState {
  hasError: boolean;
  error?: Error;
}

class ErrorBoundary extends Component<ErrorBoundaryProps, ErrorBoundaryState> {
  constructor(props: ErrorBoundaryProps) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error: Error): ErrorBoundaryState {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo): void {
    console.error('Error caught by boundary:', error, errorInfo);
  }

  render(): ReactNode {
    if (this.state.hasError) {
      return this.props.fallback || (
        <div>
          <h2>Something went wrong.</h2>
          <details>
            <summary>Error details</summary>
            <p>{this.state.error?.message}</p>
          </details>
        </div>
      );
    }

    return this.props.children;
  }
}
```

Dengan menguasai TypeScript dalam React, Anda akan dapat membangun aplikasi yang lebih aman, mudah dipelihara, dan scalable dengan pengalaman development yang lebih baik.

---

## Rangkuman

### Apa yang Telah Dipelajari

Pada modul **BAB 4.2: Pengenalan TypeScript pada React**, kita telah mempelajari:

- Konsep dasar TypeScript dan manfaatnya dalam pengembangan React
- Cara melakukan setup TypeScript pada proyek React
- Penggunaan tipe data dasar, interface, dan type alias dalam React
- Implementasi TypeScript pada props, state, dan event handlers
- Advanced TypeScript patterns seperti generic types, utility types, dan custom hooks

### Poin-Poin Penting

✅ Memahami manfaat TypeScript dalam React development
✅ Setup dan konfigurasi TypeScript pada proyek React
✅ Menggunakan interface dan tipe data untuk type safety
✅ Implementasi TypeScript pada React components dan hooks
✅ Advanced patterns seperti generic types dan utility types

---

## Evaluasi Harian

Berikut adalah tugas yang harus dikerjakan oleh santri pada hari ke-20:

1. **Setup TypeScript Project**
    - Buat proyek React baru dengan TypeScript atau konversi proyek React existing ke TypeScript.
    - Konfigurasi `tsconfig.json` dengan setting yang tepat untuk React development.
    - Pastikan project dapat dijalankan tanpa error TypeScript.

2. **Type-Safe Components**
    - Buat minimal tiga komponen React dengan TypeScript (misal: UserCard, ProductList, Form).
    - Definisikan interface untuk props dan state dengan berbagai tipe data (string, number, boolean, array, object).
    - Implementasikan event handlers dengan typed parameters.

3. **Advanced TypeScript Patterns**
    - Buat custom hook dengan generic types untuk operasi async (seperti data fetching).
    - Implementasikan utility types (Partial, Pick, Omit, Record) dalam komponen.
    - Buat type guards dan error handling dengan TypeScript.

4. **TypeScript Integration**
    - Integrasikan TypeScript dengan React Router (jika digunakan) dengan typed routes dan navigation.
    - Buat context API dengan TypeScript untuk state management.
    - Implementasikan form handling dengan validasi tipe yang ketat.

> **Catatan:**
> - Tugas dikerjakan secara individu dan dikumpulkan dalam bentuk file markdown atau dokumen digital.
> - Sertakan hasil kode (screenshot atau link repository) pada setiap tugas yang membutuhkan implementasi React dengan TypeScript.
> - Pastikan aplikasi memiliki type safety yang baik, error handling yang proper, dan mengikuti best practices TypeScript dalam React development.